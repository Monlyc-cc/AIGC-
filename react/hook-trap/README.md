# 浏览器 的 工作流程
执行js初始化dom元素（由此初始各个js执行任务） =》 渲染页面 =》（hook函数 useLayoutEffect（）执行）  =》  渲染页面 =》 （钩子函数useEffect（）函数执行） 


1. useState() // 在js初始化dom元素时执行
- useState() 执行后会返回一个 变量 与 一个 修改该变量的 set方法
- useState（） 可接收一个值，也可以接收一个函数，函数中只能执行同步代码，不支持异步
- set(),  方法的使用 ,传入一个值，或者一个函数，且函数内部会自动传入一个形参，为此时被修改变量的值
2. useEffect()

useEffect(() => {}) 会在组件初次加载和每次重新渲染时触发
useEffect(() => {}, []) 只在组件初次加载时触发
useEffect(() => {}, [x]) 初次加载，和 x 值变更时触发

### 特例
useEffect(()=>{
    return fnc
})
useEffect() 内部可以返回一个函数，在组件销毁前使用。
### 返回出的函数，执行逻辑会变
当useEffect(()=>{},[]) 只执行一次时，则组件只有所有组件销毁前才调用

3. useLayoutEffect()
 - 写法用法与useEffect() 相同
 - 但是函数的执行时机不同，会在浏览器渲染dom元素的间隙执行
 - 极大提高js执行效率，但是给浏览器带来更大的负担，影响dom元素渲染进程，
4. useReducer(reducer,vlaue)
- 将复杂的逻辑运算封装在reducer函数中，使用时只需要调用返回到dispatch可以处理更多的修改逻辑，使用起来更加简洁，复用性强。
- 对引用类型状态修改时，需要返回一个新的对象，不然react检测不到引用类型对象的变化
immer包
方便用来修改引用类型状态

5. useRef()
- 可以获取dom内部的值，
- 可以创建一个对象，不随着组件的重新加载而改变，在组件生命周期彻底结束时才消失。

6. useMemo 
- memo  函数缓存组件，当组件props值变更，才会重新加载组件
- useMemo(()=>{},[]) 缓存一个计算结果， 当【】为空时，哪怕组件重新加载，useMemo也不会内的计算也不会在此执行

7. useCallback(()=>{},[]) 缓存一个函数，当[] 为空时，哪怕组件重新加载，useCallback 也不会重新声明内部函数返回，返回到依旧是第一次声明的函数。


