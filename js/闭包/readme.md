# 作用域
- 在程序中定义变量的区域，该位置决定了变量的生命周期。通俗来讲，作用域就是变量和函数的可访问范围

# 作用域的类别
1. 全局作用域
2. 函数作用域
3. 块级作用域

# 执行上下文
1. 变量环境 ，var 与 函数声明会存在变量环境中
2. 词法环境，let 声明的变量会存在词法环境中，词法环境本质上是小型的调用栈每一个{} 都会形成一个小的词法环境，每个词法环境都有自己的作用域链。
# 作用域链
- 作用域链与函数调用过程无关，与函数所在的词法环境有关
- outer指针：每一个函数内部都会存在一个指针outer，指向该函数的外层作用域（其所在的词法作用域）
- 词法作用域：
一个函数被编译时一定会用一个outer指针记录该执行上下文（作用域）的外层（作用域）是谁。

词法作用域：函数声明的位置


# 闭包
- 两个冲突的铁律
1. 一个函数执行完毕后，它的执行上下文会从调用栈中销毁。
2. 一个函数内部的函数，一定有权力访问该外部函数中的变量（作用域规则）
- 闭包的诞生，调节上述两个铁律
1. 当调用一个外部函数中返回的内部函数时，即使外部函数已经执行结束，但是内部函数依然引用了外部函数中的变量，那么外部函数执行上下文就不能被销毁，而是会保留一个集合，用来装内部函数需要引用的变量，而这个集合就被称之为
“闭包”
- 闭包的优点：定义私有变量，封装模块。
- 缺点：内存泄漏，可能会留下过多的闭包



# 词法环境&变量环境
1. 变量环境，存储在执行上下文中的对象，用来存储配合函数执行上下文的 var声明 与 函数声明 ，js早期版本的两种变量，以及外部环境引用
2. 词法环境，存储在执行上下文中的对象，则是用来存储，let const class等等，js 后续版新出现的变量类型。，以及外部环境引用
 -  其实这两种环境中的变量声明，并没有直接存储在只执行上下文栈中，而是引用了 存储在堆栈中的“环境记录”这一对象。
 # 变量环境与词法环境
 1. 我们通常用变量环境处理函数对 var与函数的声明。使用词法环境处理let const class 等等变量的声明。
 但是实际上，这些声明并没有存储在栈中，而是引用了存储在堆中的 环境记录对象。 

 3. 词法环境pro：现代js中，词法环境内部存在两个属性，一个是环境记录：用于保存const let class等等变量声明，与一个outer指针，指向该函数执行上文的外部词法环境。
 4. 但是为了不影响老项目的运行，js保留了虽然变量环境的设计。所有的函数与var的声明也保存在环境记录中，且变量环境与词法环境引用的环境记录是相同的，且outer指针也指向相同的外部环境。
# 环境记录与outer指针
- 环境记录，存储在堆中的对象，保存某一个函数执行上下文的所有的变量，变量环境与词法环境都是引用环境变量中的数据
- outer指针，指向外部词法环境

