# 进程、线程
- 进程：cpu运行指令加载和保存上下文所需的时间。
- 线程：cpu执行一段指令需要的时间。
- 进程与线程是一个相对的概念，它本身是一个单位。已操作系统为主体，打开一个app等于打开一个进程。已浏览器为主体，每打开一个网站等于打开一个进程
- 进程可以由多个线程组成。


- 比如： 浏览器多开一个tab页，就是增加一个进程。
1. 渲染线程
2. js 引擎线程
3. HTTP请求线程 
- 图不会为js可以修改dom,所以引擎线程和渲染0线程是互斥的
等等

# v8
- v8 在是执行js的过程 默认只开一个线程
- 只有一个线程带来：异步骤
- 单线程处理代码的过程：遇到同步任务就会立即执行，遇到异步任务会存放到任务队列中，等js线程空闲时，再执行任务队列中的异步任务

# 事件循环机制
promise 本身不耗时
- 微任务：promise.then(),这个任务是否耗时，取决于promise是否消耗时间，不一定耗时的任务。process.nextTick(),MutationObserver

- 宏任务：setTimeout（），setInterval(),ajax,I/O,UI-rendering页面渲染， 一定会耗时的惹怒 

- 微任务队列：虽然微任务不一定耗时，但是v8会将其判断为异步代码，加入微任务队列，不被立即执行
- 宏任务队列：

## 执行顺序
1. 先执行同步代码（这属于宏任务），该过程如果遇到异步任务，就存入相应的异步队列
2. 同步执行完毕后，执行微任务队列中的代码。如果中途产生了新的微任务，则等到新加入到任务执行完后才会算是结束。
3. 微任务结束后，有需要的话就渲染页面。
4. 最后执行宏任务（下一次循环的开始）

- 队列中的顺序，队列中通常是先进先出，但是存在一种调度机制，队列中哪个任务先执行完，哪个任务就先出队列。

# async await
1. 函数前面加一个async 等同于函数内部返回了一个promise实例对象。
2. await必须跟async 配合使用，并且await 后面如果不接一个promise对象，await 便无法约束后面对象。
3. await fn() v8会把fn当做同步代码执行
 - 实现原理，await 会将后续的代码全部挤到微任务队列


 # 异步
 1. 同步&异步
    - v8执行代码时，只开一个工作线程工作，为提高执行效率执行效率，碰到需要耗时的代码时，v8引擎无需等待，可以将耗时代码放到任务队列中，等不耗时的代码执行完毕后，回头再执行。
    而其中：
        - 不耗时的代码，我们称之为 同步代码
        - 耗时的代码，我们称之为异步代码

# event-loop （事件循环机制）
1. 简单意义上的事件循环过程（仅供初步理解）
- j简单意义上来讲s代码的执行不断重复（执行同步代码 =》 执行异步代码）这一过程.
我们都明白，v8引擎会先执行同步代码，将耗时的异步代码放入任务队列中，等同步代码执行完毕，再回头执行耗时代码。这就构成了一个事件流，不是么？
相应的，如果异步代码内部，也包含了异步与同步代码两个部分，则会开启一个新的事件流，并且这个事件流与异步代码外层并不无差别不，都是先执行同步代码，再去执行耗时的异步代码。
所以我们把这个重复着同一过程（先执行同步，再执行异步）的机制，称之为代码执行的事件循环机制（event-loop），代表代码的执行就是不断的重复（循环）执行同步，再执行异步的这一过程


2. 异步之间亦有差异
- 异步代码，是我们主观认为下会耗时执行的代码，v8引擎会在执行过程中将异步代码单独提走，放到异步任务队列的中等待执行，然后异步代码之间亦有差距。
3. 宏任务&微任务
按照异步代码的执行时机，异步被放入两种任务队列等待执行，那就是宏任务队列与微任务队列，被放入相应队列的异步代码，我们称之为宏任务与微任务。
   1. 宏任务：等待下一轮循环执行的代码。
     比如：
     - setTimeout(),setInterval(),ajax,I/O,UI-rendering页面渲染等
     特点：
     - 依赖外部资源 ，比如：setTimeout（）依赖外部资源定时器，ajax依赖网络
     - 执行时机：需要等待下一次事件循环才能够被执行。
   2. 微任务：  
     比如：
     - promise.then()，process.nextTick(),MutationObserver
     - 不依赖外部资源，比如 promise.them()依赖promise对象状态，这都是js环境自身拥有的资源。
     - 执行时间，本次事件循环同步代码执行完毕后，立马执行

2.  事实意义上的事件循环机制（event - loop） 实际存在的可靠的
js代码的执行是不断的重复（从宏任务队列中取出一个宏任务=》执行宏任务内部同步代码=》清空微任务队列）这一过程，我们称之为事件流。
  1. 从宏任务队列中取出宏任务：
     - 一份js代码全局就是一个宏任务
     - 如果宏任务队列为空，则js引擎就陷入等待，直到新的宏任务出现
  2. 执行宏任务内部同步代码：
     - 执行宏任务内部过程中，所有的同步代码直接执行。
     - 异步代码，则被放入相应的（宏任务/ 微任务）等待序列
  3. 清空微任务队列：
     - 同步代码执行完毕后，立马开始执行微任务队列中等待执行的所有异步代码=》执行所有的微任务
     - 如果微任务队列为空，则直接进入下一步。
  4. 重复第一步 



