# 进程、线程
- 进程：cpu运行指令加载和保存上下文所需的时间。
- 线程：cpu执行一段指令需要的时间。
- 进程与线程是一个相对的概念，它本身是一个单位。已操作系统为主体，打开一个app等于打开一个进程。已浏览器为主体，每打开一个网站等于打开一个进程
- 进程可以由多个线程组成。


- 比如： 浏览器多开一个tab页，就是增加一个进程。
1. 渲染线程
2. js 引擎线程
3. HTTP请求线程 
- 图不会为js可以修改dom,所以引擎线程和渲染0线程是互斥的
等等

# v8
- v8 在是执行js的过程 默认只开一个线程
- 只有一个线程带来：异步骤
- 单线程处理代码的过程：遇到同步任务就会立即执行，遇到异步任务会存放到任务队列中，等js线程空闲时，再执行任务队列中的异步任务

# 事件循环机制
promise 本身不耗时
- 微任务：promise.then(),这个任务是否耗时，取决于promise是否消耗时间，不一定耗时的任务。process.nextTick(),MutationObserver

- 宏任务：setTimeout（），setInterval(),ajax,I/O,UI-rendering页面渲染， 一定会耗时的惹怒 

- 微任务队列：虽然微任务不一定耗时，但是v8会将其判断为异步代码，加入微任务队列，不被立即执行
- 宏任务队列：

## 执行顺序
1. 先执行同步代码（这属于宏任务），该过程如果遇到异步任务，就存入相应的异步队列
2. 同步执行完毕后，执行微任务队列中的代码。如果中途产生了新的微任务，则等到新加入到任务执行完后才会算是结束。
3. 微任务结束后，有需要的话就渲染页面。
4. 最后执行宏任务（下一次循环的开始）

- 队列中的顺序，队列中通常是先进先出，但是存在一种调度机制，队列中哪个任务先执行完，哪个任务就先出队列。

# async await
1. 函数前面加一个async 等同于函数内部返回了一个promise实例对象。
2. await必须跟async 配合使用，并且await 后面如果不接一个promise对象，await 便无法约束后面对象。
3. await fn() v8会把fn当做同步代码执行
 - 实现原理，await 会将后续的代码全部挤到微任务队列