#  函数原型：prototype （显式原型）
1. 函数天生拥有的一个属性 prototype ，该属性值是一个对象。
2. 将构造函数中的一些固定的属性和方法挂载到原型上，在创建实例的时候，就不需要重复执行这些属性与方法
3. 挂载到原型上的属性是可以直接调用的。
4. 实例对象只能访问原型，不能更改原型。
5. 默认拥有一个constructor属性，指向构造函数。


# 对象原型：__proto__ （隐式原型）
1. 每一个对象都拥有一个 __proto__ 属性，该属性值也是一个对象.
2. v8在访问对象中的一个属性时，会先访问该对象中的显式属性，如果找不到，就回去对象的隐式原型中查找
3. 实例对象的隐式原型 === 构造函数的显式原型



# 扩展 ：new函数做了什么？
我们都明白使用 new 构造函数() 便可以创建一个实例对象，大概了解一下new函数的执行过程，可以帮助我们更好的了解 __ _proto___ 与 prototype的联系。
> new Contructor() 调用后 ：new做的执行过程
> 1. 创建一个新的空对象obj
> 2. 设置obj的属性__proto__ 
>     - 将__proto__指向构造函数的prototype属性
>     - 即 obj. __ _proto___ = Constructor.prototype
> 3. 绑定构造函数的this并执行
>     - 类似于Contructor.call(obj)的过程
> 4. 判断构造函数的返回值
> - new关键字会根据 构造函数 的 返回值类型的不同 ，选择最终的返回对象
>   - 如果返回值是原始类型，则返回步骤1中创建的对象
>   - 如果返回值是引用类型，则返回该引用类型对象



# 原型链
v8 在访问对象中的属性时，会先访问该对象中的显式原型，如果找不到，就会去该对象的隐式原型上找，如果找不到就会去隐是原型的隐式原型上找，直到找到null