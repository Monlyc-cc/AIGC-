# js引擎
1. 浏然器
2. node

v8 引擎（谷歌浏览器）
- 是一段函数（庞大），它可以读懂js。


# js的执行
1. 代码被v8读取到的第一时间，不是立即执行，而是先编译（梳理）。

- 梳理：
1. 分词（词法分析），将代码划分为词法单元。
2. 解析（语法分析）- - 生成AST (抽象代码树) 
3. 生成代码（机器码）- - 将有效标识符提前了

例如：
console.log(a)
var a= 1;

1.词法分析
console.log(a)
var a
a=1

2.语法解析
var a
console.log(a)
a=1
3.生成代码（机器码）

- 所以原代码执行不报错，a（标识符）的声明被提前了，后面的输出语句可以正常执行。


# 作用域
- 在程序中定义变量的区域，该位置决定了变量的生命周期
- 全局作用域
- 函数作用域（局部作用域）,(参数也是函数作用域内的有效标识符)
- $$块级作用域（let,const和{}语法配合使用会导致声明的变量处在一个作用域中,在{}中产生了暂时性死区）。
    - 死区：区域内函数无法向外访问变量 

- 作用域只能由内往外查找 


{let a}内声明变量会形成一个死区，而不是一个新的xx执行上下文.
“函数作用域”是通过预编译时产生的“函数执行上下文”实现的，但是死区是如何实现的？

